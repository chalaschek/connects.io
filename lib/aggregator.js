// Generated by CoffeeScript 1.3.3
var Aggregator, EventEmitter, SingletoneWindow,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;

SingletoneWindow = require("./singleton-window");

Aggregator = (function(_super) {

  __extends(Aggregator, _super);

  Aggregator.prototype.id = "aggregator";

  function Aggregator(config) {
    if (config == null) {
      config = {};
    }
    Aggregator.__super__.constructor.call(this);
    this.stats = config.stats, this.window = config.window, this.groupBy = config.groupBy, this.cumulative = config.cumulative, this.emitFrequency = config.emitFrequency;
    if (!this.stats) {
      this.stats = [];
    }
    if (!this.window) {
      this.window = new SingletoneWindow();
    }
    if (this.cumulative === void 0 || this.cumulative === null) {
      this.cumulative = true;
    }
    this.aggregate = {};
    this._initEmitter();
    this._initWindowListeners();
  }

  Aggregator.prototype._initWindowListeners = function() {
    var _this = this;
    this.window.on("data:push", function(events) {
      return _this._accumulate(events);
    });
    if (!this.cumulative) {
      return this.window.on("data:pop", function(events) {
        return _this._offset(events);
      });
    }
  };

  Aggregator.prototype._initEmitter = function() {
    var _this = this;
    if (this.emitFrequency) {
      return this._interval = setInterval(function() {
        return _this.emit("data:new", _this.value());
      }, this.emitFrequency);
    } else {
      return this.on("aggregate:updated", function(data) {
        return _this.emit("data:new", data);
      });
    }
  };

  Aggregator.prototype._accumulate = function(events) {
    var data, group, stat, _groups, _i, _j, _k, _len, _len1, _len2, _ref;
    _ref = this.stats;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      stat = _ref[_i];
      for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
        data = events[_j];
        if ((data != null ? data[stat.aggregateField] : void 0) === null) {
          continue;
        }
        if (this.groupBy) {
          if (!(data != null ? data[this.groupBy] : void 0)) {
            continue;
          }
          _groups = data[this.groupBy];
          if (!(_groups instanceof Array)) {
            _groups = [_groups];
          }
          for (_k = 0, _len2 = _groups.length; _k < _len2; _k++) {
            group = _groups[_k];
            if (!this.aggregate[group]) {
              this.aggregate[group] = {};
            }
            if (!this.aggregate[group][stat.outputName]) {
              this.aggregate[group][stat.outputName] = 0;
            }
            this.aggregate[group][stat.outputName] = stat.accumulate(this.aggregate[group][stat.outputName], data[stat.aggregateField]);
          }
        } else {
          if (!this.aggregate[stat.outputName]) {
            this.aggregate[stat.outputName] = 0;
          }
          this.aggregate[stat.outputName] = stat.accumulate(this.aggregate[stat.outputName], data[stat.aggregateField]);
        }
      }
    }
    return this.emit("aggregate:updated");
  };

  Aggregator.prototype._offset = function(events) {
    var data, group, stat, _groups, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    if (this.cumulative) {
      return;
    }
    _ref = this.stats;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      stat = _ref[_i];
      for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
        data = events[_j];
        if ((data != null ? data[stat.aggregateField] : void 0) === null) {
          continue;
        }
        if (this.groupBy) {
          if (!(data != null ? data[this.groupBy] : void 0)) {
            continue;
          }
          _groups = data[this.groupBy];
          if (!(_groups instanceof Array)) {
            _groups = [_groups];
          }
          for (_k = 0, _len2 = _groups.length; _k < _len2; _k++) {
            group = _groups[_k];
            if (!((_ref1 = this.aggregate[group]) != null ? _ref1[stat.outputName] : void 0)) {
              continue;
            }
            this.aggregate[group][stat.outputName] = stat.offset(this.aggregate[group][stat.outputName], data[stat.aggregateField]);
          }
        } else {
          if (!this.aggregate[stat.outputName]) {
            continue;
          }
          this.aggregate[stat.outputName] = stat.offset(this.aggregate[stat.outputName], data[stat.aggregateField]);
        }
      }
    }
    return this.emit("aggregate:updated");
  };

  Aggregator.prototype.value = function() {
    return this.aggregate;
  };

  Aggregator.prototype.process = function(data) {
    var _this = this;
    return process.nextTick(function() {
      return _this.window.process(data);
    });
  };

  return Aggregator;

})(EventEmitter);

module.exports = Aggregator;
