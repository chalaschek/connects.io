// Generated by CoffeeScript 1.3.3
var Aggregator, EventEmitter, MemoryStore, SingletoneWindow, uuid,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;

SingletoneWindow = require("./singleton-window");

MemoryStore = require('./store').MemoryStore;

uuid = require('./uuid');

Aggregator = (function(_super) {

  __extends(Aggregator, _super);

  function Aggregator(config) {
    if (config == null) {
      config = {};
    }
    Aggregator.__super__.constructor.call(this);
    this._id = uuid();
    this._key = "" + this._id + ":aggregate";
    this.stats = config.stats, this.window = config.window, this.groupBy = config.groupBy, this.cumulative = config.cumulative, this.emitFrequency = config.emitFrequency, this.store = config.store;
    if (!this.stats) {
      this.stats = [];
    }
    if (!this.window) {
      this.window = new SingletoneWindow();
    }
    if (!this.store) {
      this.store = new MemoryStore();
    }
    this._initEmitter();
    this._initWindowListeners();
  }

  Aggregator.prototype._initWindowListeners = function() {
    var _this = this;
    this.window.on("data:push", function(events) {
      return _this._accumulate(events);
    });
    if (!this.cumulative) {
      return this.window.on("data:pop", function(events) {
        return _this._offset(events);
      });
    }
  };

  Aggregator.prototype._emitValue = function() {
    var _this = this;
    return this._value(function(error, value) {
      return _this.emit("data:new", value);
    });
  };

  Aggregator.prototype._initEmitter = function() {
    var _this = this;
    if (this.emitFrequency) {
      return this._interval = setInterval(function() {
        return _this._emitValue();
      }, this.emitFrequency);
    } else {
      this.on("aggregate:updated:accumulate", function(data) {
        return _this._emitValue();
      });
      return this.on("aggregate:updated:offset", function(data) {
        if (!(_this.window instanceof SingletoneWindow)) {
          return _this._emitValue();
        }
      });
    }
  };

  Aggregator.prototype._accumulate = function(events) {
    var data, group, stat, _groups, _i, _j, _k, _len, _len1, _len2, _ref;
    _ref = this.stats;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      stat = _ref[_i];
      for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
        data = events[_j];
        if ((data != null ? data[stat.aggregateField] : void 0) === null) {
          continue;
        }
        if (this.groupBy) {
          if (!(data != null ? data[this.groupBy] : void 0)) {
            continue;
          }
          _groups = data[this.groupBy];
          if (!(_groups instanceof Array)) {
            _groups = [_groups];
          }
          for (_k = 0, _len2 = _groups.length; _k < _len2; _k++) {
            group = _groups[_k];
            if (!this.aggregate[group]) {
              this.aggregate[group] = {};
            }
            if (!this.aggregate[group][stat.outputName]) {
              this.aggregate[group][stat.outputName] = 0;
            }
            this.aggregate[group][stat.outputName] = stat.accumulate(this.aggregate[group][stat.outputName], data[stat.aggregateField]);
          }
        } else {
          if (!this.aggregate[stat.outputName]) {
            this.aggregate[stat.outputName] = 0;
          }
          this.aggregate[stat.outputName] = stat.accumulate(this.aggregate[stat.outputName], data[stat.aggregateField]);
        }
      }
    }
    return this.emit("aggregate:updated:accumulate");
  };

  Aggregator.prototype._offset = function(events) {
    var data, group, stat, _groups, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _size;
    if (this.cumulative) {
      return;
    }
    _size = this.window.size();
    _ref = this.stats;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      stat = _ref[_i];
      for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
        data = events[_j];
        if ((data != null ? data[stat.aggregateField] : void 0) === null) {
          continue;
        }
        if (this.groupBy) {
          if (!(data != null ? data[this.groupBy] : void 0)) {
            continue;
          }
          _groups = data[this.groupBy];
          if (!(_groups instanceof Array)) {
            _groups = [_groups];
          }
          for (_k = 0, _len2 = _groups.length; _k < _len2; _k++) {
            group = _groups[_k];
            if (!((_ref1 = this.aggregate[group]) != null ? _ref1[stat.outputName] : void 0)) {
              continue;
            }
            this.aggregate[group][stat.outputName] = stat.offset(this.aggregate[group][stat.outputName], data[stat.aggregateField], _size);
          }
        } else {
          if (!this.aggregate[stat.outputName]) {
            continue;
          }
          this.aggregate[stat.outputName] = stat.offset(this.aggregate[stat.outputName], data[stat.aggregateField], _size);
        }
      }
    }
    return this.emit("aggregate:updated:offset");
  };

  Aggregator.prototype.value = function(callback) {
    var _this = this;
    return this.store.get(this._key, function(error, agg) {
      var clone, key, val;
      if (error) {
        return callback(error);
      }
      clone = {};
      for (key in agg) {
        val = agg[key];
        clone[key] = val;
      }
      return callback(null, clone);
    });
  };

  Aggregator.prototype.process = function(data) {
    var _this = this;
    return process.nextTick(function() {
      return _this.window.process(data);
    });
  };

  return Aggregator;

})(EventEmitter);

module.exports = Aggregator;
