// Generated by CoffeeScript 1.3.3
var CountStat, EventEmitter, MeanStat, MemoryStore, Stat, SumStat, async, uuid, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;

uuid = require('./uuid');

MemoryStore = require('./store').MemoryStore;

_ = require('underscore');

async = require('async');

Stat = (function(_super) {

  __extends(Stat, _super);

  Stat.prototype.defaultOutputName = "stat_name";

  function Stat(config) {
    this.aggregateField = config.aggregateField, this.outputName = config.outputName, this.store = config.store, this.groupBy = config.groupBy;
    if (!this.outputName) {
      this.outputName = this.defaultOutputName;
    }
    if (!this.store) {
      this.store = new MemoryStore();
    }
    if (!this.aggregateField) {
      throw new Error("Aggregate field must be specified");
    }
  }

  Stat.prototype._groups = function(element) {
    var groups;
    if (!this.groupBy || !(element != null ? element[this.groupBy] : void 0)) {
      return;
    }
    groups = element[this.groupBy];
    if (!(groups instanceof Array)) {
      groups = [groups];
    }
    return groups;
  };

  Stat.prototype._values = function(elements) {
    var data, group, groups, val, vals, values, _i, _j, _len, _len1;
    values = this.groupBy ? {} : [];
    for (_i = 0, _len = elements.length; _i < _len; _i++) {
      data = elements[_i];
      if (data[this.aggregateField] === null) {
        continue;
      }
      val = data[this.aggregateField];
      groups = this._groups(data);
      if (groups) {
        for (_j = 0, _len1 = groups.length; _j < _len1; _j++) {
          group = groups[_j];
          vals = values[group];
          if (!vals) {
            values[group] = vals = [];
          }
          vals.push(val);
        }
      } else {
        values.push(val);
      }
    }
    return values;
  };

  Stat.prototype._update = function(key, values, isAccumulate, callback) {
    throw new Error("Method must be implemented");
  };

  Stat.prototype.accumulate = function(elements, callback) {
    var groups, result, values,
      _this = this;
    if (!(elements instanceof Array)) {
      elements = [elements];
    }
    values = this._values(elements);
    if (values instanceof Array) {
      return this._update(this._key, values, true, function(error, value) {
        var result;
        result = {};
        result[_this.outputName] = value;
        return callback(error, result);
      });
    } else {
      groups = _.keys(values);
      result = {};
      return async.forEach(groups, function(group, cb) {
        return _this._update("" + group + ":" + _this._key, values[group], true, function(error, value) {
          var _r;
          _r = {};
          _r[_this.outputName] = value;
          result[group] = _r;
          return cb();
        });
      }, function(error) {
        return callback(error, result);
      });
    }
  };

  Stat.prototype.offset = function(elements, callback) {
    var groups, result, values,
      _this = this;
    if (!(elements instanceof Array)) {
      elements = [elements];
    }
    values = this._values(elements);
    if (values instanceof Array) {
      return this._update(this._key, values, false, function(error, value) {
        var result;
        result = {};
        result[_this.outputName] = value;
        return callback(error, result);
      });
    } else {
      groups = _.keys(values);
      result = {};
      return async.forEach(groups, function(group, cb) {
        return _this._update("" + group + ":" + _this._key, values[group], false, function(error, value) {
          var _r;
          _r = {};
          _r[_this.outputName] = value;
          result[group] = _r;
          return cb();
        });
      }, function(error) {
        return callback(error, result);
      });
    }
  };

  return Stat;

})(EventEmitter);

SumStat = (function(_super) {

  __extends(SumStat, _super);

  function SumStat() {
    return SumStat.__super__.constructor.apply(this, arguments);
  }

  SumStat.prototype.defaultOutputName = "sum";

  SumStat.prototype._key = "sum";

  SumStat.prototype._update = function(key, values, isAccumulate, callback) {
    var _this = this;
    return this.store.get(key, function(error, curr) {
      var newValue, val;
      if (curr == null) {
        curr = 0;
      }
      if (error) {
        return callback(error);
      }
      newValue = _.reduce(values, (function(memo, num) {
        return memo + num;
      }), 0);
      if (isAccumulate) {
        val = curr + newValue;
      } else {
        val = curr - newValue;
      }
      return _this.store.put(key, val, function(error) {
        if (error) {
          return callback(error);
        }
        return callback(null, val);
      });
    });
  };

  return SumStat;

})(Stat);

CountStat = (function(_super) {

  __extends(CountStat, _super);

  function CountStat() {
    return CountStat.__super__.constructor.apply(this, arguments);
  }

  CountStat.prototype.defaultOutputName = "count";

  CountStat.prototype._key = "count";

  CountStat.prototype._update = function(key, values, isAccumulate, callback) {
    var _this = this;
    return this.store.get(key, function(error, curr) {
      var newValue, val;
      if (curr == null) {
        curr = 0;
      }
      if (error) {
        return callback(error);
      }
      newValue = values.length;
      if (isAccumulate) {
        val = curr + newValue;
      } else {
        val = curr - newValue;
      }
      return _this.store.put(key, val, function(error) {
        if (error) {
          return callback(error);
        }
        return callback(null, val);
      });
    });
  };

  return CountStat;

})(Stat);

MeanStat = (function(_super) {

  __extends(MeanStat, _super);

  function MeanStat() {
    return MeanStat.__super__.constructor.apply(this, arguments);
  }

  MeanStat.prototype.defaultOutputName = "mean";

  MeanStat.prototype._key = "mean";

  MeanStat.prototype._update = function(key, values, isAccumulate, callback) {
    var _this = this;
    return this.store.get(key, function(error, data) {
      var n, newValue;
      if (data == null) {
        data = {
          n: 0,
          mean: 0
        };
      }
      if (error) {
        return callback(error);
      }
      newValue = _.reduce(values, (function(memo, num) {
        return memo + num;
      }), 0);
      n = values.length;
      if (isAccumulate) {
        data.mean = ((data.mean * data.n) + newValue) / (data.n + n);
        data.n += n;
      } else {
        if (data.n - n === 0) {
          data.mean = 0;
        } else {
          data.mean = ((data.mean * data.n) - newValue) / (data.n - n);
        }
        data.n -= n;
      }
      return _this.store.put(key, data, function(error) {
        if (error) {
          return callback(error);
        }
        return callback(null, data.mean);
      });
    });
  };

  return MeanStat;

})(Stat);

module.exports = {
  Stat: Stat,
  SumStat: SumStat,
  CountStat: CountStat,
  MeanStat: MeanStat
};
